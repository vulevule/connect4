{"version":3,"sources":["consts/Consts.js","utils/Utils.js","classes/Position.js","classes/Solver.js","App.js","serviceWorker.js","index.js"],"names":["EVAL_WEIGHTS","EASY","MEDIUM","HARD","MAX_VALUE","Number","MIN_VALUE","checkHorizontal","board","size","heigth","length","r","c","count","tokens","e","push","checkDiagonalRight","checkDiagonalLeft","width","checkDraw","checkAll","checkVertical","evaluationCheck","checkedDL","checkedDR","checkedH","playable","clone","obj","JSON","parse","stringify","Position","currentPlayer","isWinningMove","checked","play","togglePlayer","this","Solver","negamax","position","columns","value","console","log","move","bestScore","p2","score","negamaxAB","alpha","beta","depth","evaluate","result","minimax","myFours","myThrees","myTwos","oppFours","oppThrees","oppTwos","boardCopy","opponent","runMinimax","bestMove","solve","type","Array","keys","sort","a","b","Math","abs","indexOf","App","props","handleDepthChange","setState","target","initBoard","state","player1","player2","fill","initialPlayer","round","random","connected","gameOver","message","setTimeout","floor","newPlayer","computeScores","playHuman","ToastsStore","warning","playAI","success","error","render","className","onChange","name","onClick","css","sizeUnit","color","loading","map","row","i","key","rowIndex","store","ToastsContainerPosition","TOP_CENTER","bind","Component","Row","cell","columnIndex","some","every","v","Cell","Boolean","window","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"yVAAaA,EACJ,GADIA,EAEH,EAFGA,EAGL,EAGKC,EAAO,EACPC,EAAS,EACTC,EAAO,EAEPC,EAAYC,OAAOD,UACnBE,GAAaD,OAAOD,UCoB1B,SAASG,EAAgBC,GAG9B,IAHgD,IAAXC,EAAU,uDAAH,EACxCC,EAASF,EAAMG,OAEVC,EAAI,EAAGA,EAAIF,EAAQE,IAC1B,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAMI,IACxB,GAAIL,EAAMI,GAAGC,GAGX,IAFA,IAAIC,EAAQ,EACRC,EAAS,CAAC,CAACH,EAAGC,IACTG,EAAI,EAAGA,EAAIP,EAAMO,IACxB,GAAIR,EAAMI,GAAGC,KAAOL,EAAMI,GAAGC,EAAIG,IAG/B,GAFAF,IACAC,EAAOE,KAAK,CAACL,EAAGC,EAAIG,IAChBF,GAASL,EAAM,MAAO,CAACD,EAAMI,GAAGC,GAAIE,QAExCD,EAAQ,EACRC,EAAS,CAAC,CAACH,EAAGC,IAgBnB,SAASK,EAAmBV,GAGjC,IAHmD,IAAXC,EAAU,uDAAH,EAC3CC,EAASF,EAAMG,OAEVC,EAAIH,EAAO,EAAGG,EAAIF,EAAQE,IACjC,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAMI,IACxB,GAAIL,EAAMI,GAAGC,GAGX,IAFA,IAAIC,EAAQ,EACRC,EAAS,CAAC,CAACH,EAAGC,IACTG,EAAI,EAAGA,EAAIP,EAAMO,IACxB,GAAIR,EAAMI,GAAGC,KAAOL,EAAMI,EAAII,GAAGH,EAAIG,IAGnC,GAFAF,IACAC,EAAOE,KAAK,CAACL,EAAII,EAAGH,EAAIG,IACpBF,GAASL,EAAM,MAAO,CAACD,EAAMI,GAAGC,GAAIE,QAExCD,EAAQ,EACRC,EAAS,CAAC,CAACH,EAAGC,IAgBnB,SAASM,EAAkBX,GAGhC,IAHkD,IAAXC,EAAU,uDAAH,EAAG,EAC3B,CAACD,EAAM,GAAGG,OAAQH,EAAMG,QAAzCS,EAD4C,KACrCV,EADqC,KAGxCE,EAAIH,EAAO,EAAGG,EAAIF,EAAQE,IACjC,IAAK,IAAIC,EAAIJ,EAAO,EAAGI,EAAIO,EAAOP,IAChC,GAAIL,EAAMI,GAAGC,GAGX,IAFA,IAAIC,EAAQ,EACRC,EAAS,CAAC,CAACH,EAAGC,IACTG,EAAI,EAAGA,EAAIP,EAAMO,IACxB,GAAIR,EAAMI,GAAGC,KAAOL,EAAMI,EAAII,GAAGH,EAAIG,IAGnC,GAFAF,IACAC,EAAOE,KAAK,CAACL,EAAII,EAAGH,EAAIG,IACpBF,GAASL,EAAM,MAAO,CAACD,EAAMI,GAAGC,GAAIE,QAExCD,EAAQ,EACRC,EAAS,CAAC,CAACH,EAAGC,IAgBnB,SAASQ,EAAUb,GAExB,IAFgC,IAAD,EACT,CAACA,EAAM,GAAGG,OAAQH,EAAMG,QAAzCS,EAD0B,KACnBV,EADmB,KAEtBE,EAAI,EAAGA,EAAIF,EAAQE,IAC1B,IAAK,IAAIC,EAAI,EAAGA,EAAIO,EAAOP,IACzB,GAAoB,OAAhBL,EAAMI,GAAGC,GACX,OAAO,KAIb,MAAO,OAGF,SAASS,EAASd,GAAkB,IAAXC,EAAU,uDAAH,EACrC,OAzIK,SAAuBD,GAG5B,IAH8C,IAAXC,EAAU,uDAAH,EAAG,EACvB,CAACD,EAAM,GAAGG,OAAQH,EAAMG,QAAzCS,EADwC,KACjCV,EADiC,KAGpCE,EAAIH,EAAO,EAAGG,EAAIF,EAAQE,IACjC,IAAK,IAAIC,EAAI,EAAGA,EAAIO,EAAOP,IACzB,GAAIL,EAAMI,GAAGC,GAGX,IAFA,IAAIC,EAAQ,EACRC,EAAS,CAAC,CAACH,EAAGC,IACTG,EAAI,EAAGA,EAAIP,EAAMO,IACxB,GAAIR,EAAMI,GAAGC,KAAOL,EAAMI,EAAII,GAAGH,IAG/B,GAFAC,IACAC,EAAOE,KAAK,CAACL,EAAII,EAAGH,IAChBC,GAASL,EAAM,MAAO,CAACD,EAAMI,GAAGC,GAAIE,QAExCD,EAAQ,EACRC,EAAS,CAAC,CAACH,EAAGC,IA2HtBU,CAAcf,EAAOC,IACrBS,EAAmBV,EAAOC,IAC1BU,EAAkBX,EAAOC,IACzBF,EAAgBC,EAAOC,IACvBY,EAAUb,GAIP,SAASgB,EAAgBhB,GAAkB,IAAXC,EAAU,uDAAH,EACxCgB,EAAYN,EAAkBX,EAAOC,GACrCiB,EAAYR,EAAmBV,EAAOC,GACtCkB,EAAWpB,EAAgBC,EAAOC,GAEtC,OACGgB,GAAaA,EAAU,IACvBC,GAAaA,EAAU,IACvBC,GAAYA,EAAS,GAInB,SAASC,EAASf,EAAGL,GAC1B,IAAK,IAAII,EAAIJ,EAAMG,OAAS,EAAGC,GAAK,EAAGA,IACrC,IAAKJ,EAAMI,GAAGC,GACZ,OAAO,EAIX,OAAO,EAGF,SAASgB,EAAMC,GACpB,OAAOC,KAAKC,MAAMD,KAAKE,UAAUH,I,ICvKdI,EACnB,aAA4C,IAAD,OAA/B1B,EAA+B,uDAAvB,GAAI2B,EAAmB,uDAAH,EAAG,yBAK3CC,cAAgB,SAAAvB,GAKd,IAJA,IAAIL,EAAQqB,EAAM,EAAKrB,OACnBE,EAASF,EAAMG,OACbwB,EAAkB,EAAlBA,cAEGvB,EAAIF,EAAS,EAAGE,GAAK,EAAGA,IAC/B,IAAKJ,EAAMI,GAAGC,GAAI,CAChBL,EAAMI,GAAGC,GAAKsB,EACd,IAAIE,EAAUf,EAASd,GACvB,OAAO6B,GAAWF,IAAkBE,EAAQ,KAdP,KAmB3CC,KAAO,SAACzB,GAIN,IAJiC,IAAxBL,EAAuB,uDAAf,EAAKA,MAChB2B,EAAkB,EAAlBA,cACFzB,EAASF,EAAMG,OAEVC,EAAIF,EAAS,EAAGE,GAAK,EAAGA,IAC/B,IAAKJ,EAAMI,GAAGC,GAAI,CAChBL,EAAMI,GAAGC,GAAKsB,EACd,MAMJ,OAFA,EAAKI,eAEE/B,GAhCkC,KAmC3C+B,aAAe,WACb,EAAKJ,eAAiB,EAAKA,eAnC3BK,KAAKhC,MAAQA,EACbgC,KAAKL,cAAgBA,GCDJM,EACnB,WAAYrB,GAAQ,IAAD,gCAWnBsB,QAAU,SAAAC,GAAa,IACfC,EAAY,EAAZA,QADc,EAEWf,EAAMc,GAA/BnC,EAFc,EAEdA,MAAO2B,EAFO,EAEPA,cAGb,GAAId,EAAUb,GACZ,MAAO,CAAEqC,MAAO,GAGlBC,QAAQC,IAAI,QAASvC,EAAO,SAAU2B,GATlB,2BAWpB,YAAcS,EAAd,+CAAuB,CAAC,IAAf/B,EAAc,QACrB,GAAIe,EAASf,EAAGL,IACVmC,EAASP,cAAcvB,GAEzB,OADAiC,QAAQC,IAAI,WAAalC,GAClB,CAAEmC,KAAMnC,EAAGgC,MAAOzC,IAfX,kFAoBpB,IAAI6C,EAAY,CAAED,KAAM,KAAMH,MAAOvC,GApBjB,uBAsBpB,YAAcsC,EAAd,+CAAuB,CAAC,IAAf/B,EAAc,QACrB,GAAIe,EAASf,EAAGL,GAAQ,CACtB,IAAI0C,EAAK,IAAIhB,EAAS1B,EAAO2B,GAC7Be,EAAGZ,KAAKzB,GAER,IAAIsC,GAAS,EAAKT,QAAQQ,GAC1BJ,QAAQC,IACN,QACAG,EAAG1C,MACH,SACA0C,EAAGf,cACH,QACAgB,EAAMN,OAGJM,EAAMN,MAAQI,EAAUJ,QAAOI,EAAYE,KArC/B,kFAyCpB,OAAOF,GApDU,KAuDnBG,UAAY,SAACT,EAAUU,EAAOC,EAAMC,GAAW,IACvCX,EAAY,EAAZA,QACApC,EAAyBmC,EAAzBnC,MAAO2B,EAAkBQ,EAAlBR,cAKb,GAAId,EAAUb,GACZ,MAAO,CAAEqC,MAAO,GAR0B,2BAY5C,YAAcD,EAAd,+CAAuB,CAAC,IAAf/B,EAAc,QACrB,GAAIe,EAASf,EAAGL,IACVmC,EAASP,cAAcvB,GAEzB,MAAO,CAAEmC,KAAMnC,EAAGgC,MAAOzC,IAhBa,kFAsB5C,IAAI8C,EAAK,IAAIhB,EAASL,EAAMrB,IAAS2B,GAtBO,uBAuB5C,YAAcS,EAAd,+CAAuB,CAAC,IAAf/B,EAAc,QACrB,GAAIe,EAASf,EAAGL,IACV0C,EAAGd,cAAcvB,GAEnB,MAAO,CAAEmC,KAAMnC,EAAGgC,MAAOzC,IA3Ba,kFAgC5C,GAAc,IAAVmD,EAGF,MAAO,CAAEV,MAFGV,EAAgB,EAAKqB,SAAS3B,EAAMc,KAKlD,IAAIM,EAAY,CAAED,KAAM,KAAMH,MAAOvC,GAtCO,uBAyC5C,YAAcsC,EAAd,+CAAuB,CAAC,IAAf/B,EAAc,QACrB,GAAIe,EAASf,EAAGL,GAAQ,CACtB,IAAI0C,EAAK,IAAIhB,EAASL,EAAMrB,GAAQ2B,GAEpCe,EAAGZ,KAAKzB,GAER,IAAI4C,EAAS,EAAKL,UAChBF,EACA,CAAEF,KAAMM,EAAKN,KAAMH,OAAQS,EAAKT,OAChC,CAAEG,KAAMK,EAAML,KAAMH,OAAQQ,EAAMR,OAClCU,EAAQ,GAiBV,GAfAE,EAAOZ,OAASY,EAAOZ,MAClBY,EAAOT,OAAMS,EAAOT,KAAOnC,GAM5B4C,EAAOZ,MAAQI,EAAUJ,QAC3BI,EAAYpB,EAAM4B,IAGhBR,EAAUJ,MAAQQ,EAAMR,QAC1BQ,EAAQxB,EAAMoB,IAGZI,EAAMR,OAASS,EAAKT,MACtB,OAAOhB,EAAMwB,KArEyB,kFA0E5C,OAAOJ,GAjIU,KAoInBS,QAAU,SAACf,EAAUU,EAAOC,EAAMC,GAAW,IACrCX,EAAY,EAAZA,QACApC,EAAyBmC,EAAzBnC,MAAO2B,EAAkBQ,EAAlBR,cAEbW,QAAQC,IAAI,SAAUvC,EAAO,SAAU2B,EAAe,SAAUoB,GAJtB,2BAO1C,YAAcX,EAAd,+CAAuB,CAAC,IAAf/B,EAAc,QACrB,GAAIe,EAASf,EAAGL,IACVmC,EAASP,cAAcvB,GAEzB,OADAiC,QAAQC,IAAI,WAAalC,GAClBT,GAX6B,kFAiB1C,IAAI8C,EAAK,IAAIhB,EAAS1B,GAAQ2B,GAjBY,uBAkB1C,YAAcS,EAAd,+CAAuB,CAAC,IAAf/B,EAAc,QACrB,GAAIe,EAASf,EAAGL,IACV0C,EAAGd,cAAcvB,GAEnB,OADAiC,QAAQC,IAAI,WAAalC,GAClBT,GAtB6B,kFA2B1C,GAAc,IAAVmD,EAAa,CACf,IAAIV,EAAQ,EAAKW,SAASb,GAE1B,OADAG,QAAQC,IAAI,cAAgBF,GACrBA,EAIT,IAAuB,IAAnBV,EAAsB,CACxB,IAAIc,EAAY3C,EADQ,uBAGxB,YAAcsC,EAAd,+CAAuB,CAAC,IAAf/B,EAAc,QACrB,GAAIe,EAASf,EAAGL,GAAQ,CACtB,IAAI0C,EAAK,IAAIhB,EAAS1B,EAAO2B,GAC7Be,EAAGZ,KAAKzB,GAER,IAAI4C,EAAS,EAAKC,QAAQR,EAAIG,EAAOC,EAAMC,EAAQ,GASnD,GANIE,EAASR,IACXA,EAAYpB,EAAM4B,IAEhBR,EAAYI,IACdA,EAAQxB,EAAMoB,IAEZI,GAASC,EACX,QAlBkB,kFAsBxB,OAAOL,EAIP,IAAIA,EAAY7C,EADb,uBAGH,YAAcwC,EAAd,+CAAuB,CAAC,IAAf/B,EAAc,QACrB,GAAIe,EAASf,EAAGL,GAAQ,CACtB,IAAI0C,EAAK,IAAIhB,EAAS1B,EAAO2B,GAC7Be,EAAGZ,KAAKzB,GAER,IAAI4C,EAAS,EAAKC,QAAQR,EAAIG,EAAOC,EAAMC,EAAQ,GASnD,GANIE,EAASR,IACXA,EAAYpB,EAAM4B,IAEhBR,EAAYI,IACdA,EAAQxB,EAAMoB,IAEZI,GAASC,EACX,QAlBH,kFAsBH,OAAOL,GArNQ,KAyNnBO,SAAW,SAAAb,GAST,IATsB,IAChBnC,EAAyBmC,EAAzBnC,MAAO2B,EAAkBQ,EAAlBR,cADQ,EAEC,CAAC3B,EAAM,GAAGG,OAAQH,EAAMG,QAAzCS,EAFgB,KAETV,EAFS,KAGjBiD,EAAU,EACVC,EAAW,EACXC,EAAS,EACTC,EAAW,EACXC,EAAY,EACZC,EAAU,EACLpD,EAAI,EAAGA,EAAIF,EAAQE,IAC1B,IAAK,IAAIC,EAAI,EAAGA,EAAIO,EAAOP,IACzB,IAAKL,EAAMI,GAAGC,GAAI,CAChB,IAAIoD,EAAYpC,EAAMrB,GAEtByD,EAAUrD,GAAGC,GAAKsB,EACdA,IAAkBX,EAAgByC,EAAW,IAAIN,IACjDxB,IAAkBX,EAAgByC,EAAW,IAAIL,IACjDzB,IAAkBX,EAAgByC,EAAW,IAAIJ,IAErD,IAAIK,GAAY/B,EAChB8B,EAAUrD,GAAGC,GAAKqD,EACdA,IAAa1C,EAAgByC,EAAW,IAAIH,IAC5CI,IAAa1C,EAAgByC,EAAW,IAAIF,IAC5CG,IAAa1C,EAAgByC,EAAW,IAAID,IAUtD,OAJGL,EAAUG,GAAY9D,GACtB4D,EAAWG,GAAa/D,GACxB6D,EAASG,GAAWhE,GAxPN,KA6PnBmE,WAAa,SAAC3D,EAAO2B,EAAeoB,GAAU,IAEtCX,EAAY,EAAZA,QAEFK,EAAY3C,EACZ8D,EAAW,KACXf,EAAQ,CAAER,MAAOvC,GACjBgD,EAAO,CAAET,MAAOzC,GAPwB,uBAS5C,YAAcwC,EAAd,+CAAuB,CAAC,IAAf/B,EAAc,QACrB,GAAIe,EAASf,EAAGL,GAAQ,CACtB,IAAI0C,EAAK,IAAIhB,EAAS1B,EAAO2B,GAC7Be,EAAGZ,KAAKzB,GAER,IAAI4C,EAAS,EAAKC,QAAQR,EAAIG,EAAOC,EAAMC,GAEvCN,EAAYQ,IACdR,EAAYpB,EAAM4B,GAClBW,EAAWvD,KAlB2B,kFAuB5C,MAAO,CAAEmC,KAAMoB,EAAUvB,MAAOI,IApRf,KAuRnBoB,MAAQ,SAAC7D,EAAO2B,EAAeoB,GAAqB,IAAde,EAAa,uDAAN,EACvC3B,EAAW,IAAIT,EAAS1B,EAAO2B,GACnC,OAAa,IAATmC,EACK,EAAKlB,UACVT,EACA,CAAEE,MAAOvC,GACT,CAAEuC,MAAOzC,GACTmD,GAEgB,IAATe,EACF,EAAK5B,QAAQC,GAEb,EAAKwB,WAAW3D,EAAO2B,EAAeoB,IAlS/C,IAAIX,EAAO,YAAO2B,MAAMnD,GAAOoD,QAC/B5B,EAAQ6B,MACN,SAACC,EAAGC,GAAJ,OACEC,KAAKC,IAAIjC,EAAQkC,QAAQJ,GAAK9B,EAAQjC,OAAS,GAC/CiE,KAAKC,IAAIjC,EAAQkC,QAAQH,GAAK/B,EAAQjC,OAAS,MAGnD6B,KAAKI,QAAUA,GCDEmC,E,YACnB,WAAYC,GAAQ,IAAD,8BACjB,4CAAMA,KAsBRC,kBAAoB,SAAAjE,GAClB,EAAKkE,SAAS,CAAE3B,MAAOvC,EAAEmE,OAAOtC,SAxBf,EA2BnBuC,UAAY,WAGV,IAHiB,IAAD,EAC0B,EAAKC,MAAzCjE,EADU,EACVA,MAAOV,EADG,EACHA,OAAQ4E,EADL,EACKA,QAASC,EADd,EACcA,QAC1B/E,EAAQ,GACHI,EAAI,EAAGA,EAAIF,EAAQE,IAC1BJ,EAAMS,KAAK,IAAIsD,MAAMnD,GAAOoE,KAAK,OAGnC,IACIC,EADU,CAACH,EAASC,GACIX,KAAKc,MAAMd,KAAKe,WAE5C,EAAKT,SAAS,CACZ1E,QACAoF,UAAW,GACXzD,cAAesD,EACfI,UAAU,EACVC,QAAS,KAGPL,IAAkBF,GACpBQ,YAAW,WAAO,IAAD,EACU,EAAKzD,KAC5BsC,KAAKoB,MAAM5E,EAAQ,GAAKwD,KAAKc,MAAMd,KAAKe,UACxCF,GAHa,mBACVjF,EADU,KACHyF,EADG,KAKf,EAAKf,SAAS,CAAE1E,QAAO2B,cAAe8D,MACrC,MApDY,EAwDnB1D,aAAe,WACb,OAAO,EAAK8C,MAAMlD,gBAAkB,EAAKkD,MAAMC,QAC3C,EAAKD,MAAME,QACX,EAAKF,MAAMC,SA3DE,EA8DnBY,cAAgB,SAAC1F,EAAO2B,GACtB,GAAIA,IAAkB,EAAKkD,MAAME,QAAS,CAAC,IAAD,EACjB,EAAKF,MAAtB9B,EADkC,EAClCA,MAAOnC,EAD2B,EAC3BA,MAKb,OAHa,IAAIqB,EAAOrB,GAEFiD,MAAMxC,EAAMrB,GAAQ2B,EAAeoB,KApE1C,EA2EnB4C,UA3EmB,uCA2EP,WAAMtF,GAAN,6BAAA6D,EAAA,2DACiC,EAAKW,MAA1CQ,EADI,EACJA,SAAU1D,EADN,EACMA,cAAeoD,EADrB,EACqBA,SAC3BM,EAFM,uBAGRO,cAAYC,QAAQ,uCAHZ,6BAONlE,IAAkBoD,EAPZ,uBAQRa,cAAYC,QAAQ,6BARZ,+BAYe,EAAK/D,KAAKzB,GAZzB,mBAYLL,EAZK,KAYEyF,EAZF,KAaLzF,GAAUyF,EAbL,oEAcJ,EAAKf,SAAS,CAAE1E,QAAO2B,cAAe8D,IAdlC,QAeVF,YAAW,WACT,EAAKO,OAAO9F,EAAOyF,KAClB,KAjBO,4CA3EO,wDA+FnBK,OAAS,WAGH,IAFJ9F,EAEG,uDAFK,EAAK6E,MAAM7E,MACnB2B,EACG,uDADa,EAAKkD,MAAMlD,cACxB,EACyB,EAAKkD,MAA3BQ,EADH,EACGA,SAAUP,EADb,EACaA,QAChB,IAAIO,GAAY1D,IAAkBmD,EAAlC,CAGA,IAAIlB,EAAW,EAAK8B,cAAcrE,EAAMrB,GAAQ2B,GAChD,EAAKG,KAAK8B,EAASpB,QAxGF,EA2GnBV,KAAO,SAACzB,GAAiD,IAA9CsB,EAA6C,uDAA7B,EAAKkD,MAAMlD,cAAkB,EACZ,EAAKkD,MAAzC7E,EADgD,EAChDA,MAAOE,EADyC,EACzCA,OAAQ4E,EADiC,EACjCA,QAASC,EADwB,EACxBA,QAC1BU,GAAa9D,EAEjB,IAAIP,EAASf,EAAGL,GAqCd,OADA4F,cAAYC,QAAQ,kCACb,CAAC,KAAM,MAnCd,IAAK,IAAIzF,EAAIF,EAAS,EAAGE,GAAK,EAAGA,IAC/B,IAAKJ,EAAMI,GAAGC,GAAI,CAChBL,EAAMI,GAAGC,GAAKsB,EACd,MAKJ,IAAIsB,EAASnC,EAASd,GACtB,GAAIiD,GAAUA,EAAO,KAAO6B,EAC1B,EAAKJ,SAAS,CACZ1E,QACAoF,UAAWnC,EAAO,GAClBoC,UAAU,EACV1D,cAAe,OAEjBiE,cAAYG,QAAQ,iBACf,GAAI9C,GAAUA,EAAO,KAAO8B,EACjC,EAAKL,SAAS,CACZ1E,QACAoF,UAAWnC,EAAO,GAClBoC,UAAU,EACV1D,cAAe,OAEjBiE,cAAYI,MAAM,iBACb,IAAe,SAAX/C,EAKT,OADA,EAAKyB,SAAS,CAAE1E,QAAO2B,cAAe8D,IAC/B,CAACzF,EAAOyF,GAJf,EAAKf,SAAS,CAAE1E,QAAOqF,UAAU,EAAM1D,cAAe,OACtDiE,cAAYC,QAAQ,cAWxB,MAAO,CAAC,KAAM,OAvJG,EA0JnBI,OAAS,WAAO,IAAD,EAUT,EAAKpB,MARP7E,EAFW,EAEXA,MACAsF,EAHW,EAGXA,QACAD,EAJW,EAIXA,SACAtC,EALW,EAKXA,MACApB,EANW,EAMXA,cACAmD,EAPW,EAOXA,QACAC,EARW,EAQXA,QACAK,EATW,EASXA,UAEF,OACE,6BACE,uBAAGc,UAAU,WAAb,mBACmB,IACjB,2BACE7D,MAAO5C,EACP0G,SAAU,EAAK1B,kBACf5C,QAASkB,EAAQrD,EACjB0G,KAAK,QACLtC,KAAK,UAEP,yCACA,2BACEzB,MAAO3C,EACPyG,SAAU,EAAK1B,kBAEf2B,KAAK,QACLtC,KAAK,UAEP,2CACA,2BACEzB,MAAO1C,EACPwG,SAAU,EAAK1B,kBAEf2B,KAAK,QACLtC,KAAK,UAEP,0CAEF,uBAAGoC,UAAU,QACX,qCADF,uEAIA,uBAAGA,UAAU,QAAb,mEACA,yBACEA,UAAU,SACVG,QAAS,WACP,EAAKzB,cAHT,YASA,yBAAKsB,UAAU,kBACb,kBAAC,IAAD,CACEI,IAAK,sBACLC,SAAU,KACVtG,KAAM,IACNuG,MAAO,UACPC,QAAS9E,IAAkBoD,IAE7B,2BACEmB,UAAWvE,IAAkBoD,EAAU,eAAiB,SAExD,gCACA,+BACG/E,EAAM0G,KAAI,SAACC,EAAKC,GAAN,OACT,kBAAC,EAAD,CACEC,IAAKD,EACLE,SAAUF,EACVD,IAAKA,EACL7E,KAAM,EAAK6D,UACXpF,OAAQ6E,EACRC,SAAUA,UAOpB,uBAAGa,UAAU,WACVb,EACG,GACA1D,IAAkBmD,EAClB,eACA,mBAEN,uBAAGoB,UAAU,WAAWZ,GAExB,kBAAC,kBAAD,CACEyB,MAAOnB,cACPzD,SAAU6E,0BAAwBC,eAnPxC,EAAKpC,MAAQ,CACXjE,MAAO,EACPV,OAAQ,EACR4E,QAAS,EACTC,SAAU,EACVpD,cAAe,KACf3B,MAAO,GACPoF,UAAW,GACXC,UAAU,EACVC,QAAS,GACTvC,MAAO,GAGT,EAAKjB,KAAO,EAAKA,KAAKoF,KAAV,gBAhBK,E,iFAoBjBlF,KAAK4C,gB,GArBwBuC,aA8P3BC,EAAM,SAAC,GAA+C,IAA7CN,EAA4C,EAA5CA,SAAUH,EAAkC,EAAlCA,IAAK7E,EAA6B,EAA7BA,KAAMvB,EAAuB,EAAvBA,OAAQ8E,EAAe,EAAfA,SAC1C,OACE,4BACGsB,EAAID,KAAI,SAACW,EAAMT,GAAP,OACP,kBAAC,EAAD,CACEC,IAAKD,EACLvE,MAAOgF,EACPC,YAAaV,EACb9E,KAAMA,EACNsD,UAAW7E,EAAOgH,MAAK,SAAArD,GAAC,MACtB,CAAC4C,EAAUF,GAAGY,OAAM,SAACC,EAAGb,GAAJ,OAAUa,IAAMvD,EAAE0C,SAExCvB,SAAUA,SAOdqC,EAAO,SAAC,GAAuD,IAArDrF,EAAoD,EAApDA,MAAOiF,EAA6C,EAA7CA,YAAaxF,EAAgC,EAAhCA,KAAMsD,EAA0B,EAA1BA,UAAWC,EAAe,EAAfA,SAC/CmB,EAAQ,QAOZ,OANc,IAAVnE,EACFmE,EAAQ,OACY,IAAXnE,IACTmE,EAAQ,UAIR,4BACE,yBACEN,UAAS,eACPb,EAAYD,EAAY,YAAc,eAAkB,IAE1DiB,QAAS,WACPvE,EAAKwF,KAGP,yBAAKpB,UAAWM,OCnSJmB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAAS/B,OAAO,kBAAC,EAAD,MAASgC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.6b94d69c.chunk.js","sourcesContent":["export const EVAL_WEIGHTS = {\r\n  FOURS: 10,\r\n  THREES: 5,\r\n  TWOS: 2\r\n};\r\n\r\nexport const EASY = 2;\r\nexport const MEDIUM = 5;\r\nexport const HARD = 7;\r\n\r\nexport const MAX_VALUE = Number.MAX_VALUE;\r\nexport const MIN_VALUE = -Number.MAX_VALUE;\r\n","export function checkVertical(board, size = 4) {\r\n  let [width, heigth] = [board[0].length, board.length];\r\n  // Check only if row is 3 or greater\r\n  for (let r = size - 1; r < heigth; r++) {\r\n    for (let c = 0; c < width; c++) {\r\n      if (board[r][c]) {\r\n        let count = 1;\r\n        let tokens = [[r, c]];\r\n        for (let e = 1; e < size; e++) {\r\n          if (board[r][c] === board[r - e][c]) {\r\n            count++;\r\n            tokens.push([r - e, c]);\r\n            if (count >= size) return [board[r][c], tokens];\r\n          } else {\r\n            count = 0;\r\n            tokens = [[r, c]];\r\n          }\r\n        }\r\n\r\n        // if (\r\n        //   board[r][c] === board[r - 1][c] &&\r\n        //   board[r][c] === board[r - 2][c] &&\r\n        //   board[r][c] === board[r - 3][c]\r\n        // ) {\r\n        //   return board[r][c];\r\n        // }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function checkHorizontal(board, size = 4) {\r\n  let heigth = board.length;\r\n  // Check only if column is 3 or less\r\n  for (let r = 0; r < heigth; r++) {\r\n    for (let c = 0; c < size; c++) {\r\n      if (board[r][c]) {\r\n        let count = 1;\r\n        let tokens = [[r, c]];\r\n        for (let e = 1; e < size; e++) {\r\n          if (board[r][c] === board[r][c + e]) {\r\n            count++;\r\n            tokens.push([r, c + e]);\r\n            if (count >= size) return [board[r][c], tokens];\r\n          } else {\r\n            count = 0;\r\n            tokens = [[r, c]];\r\n          }\r\n        }\r\n\r\n        // if (\r\n        //   board[r][c] === board[r][c + 1] &&\r\n        //   board[r][c] === board[r][c + 2] &&\r\n        //   board[r][c] === board[r][c + 3]\r\n        // ) {\r\n        //   return board[r][c];\r\n        // }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function checkDiagonalRight(board, size = 4) {\r\n  let heigth = board.length;\r\n  // Check only if row is 3 or greater AND column is 3 or less\r\n  for (let r = size - 1; r < heigth; r++) {\r\n    for (let c = 0; c < size; c++) {\r\n      if (board[r][c]) {\r\n        let count = 1;\r\n        let tokens = [[r, c]];\r\n        for (let e = 1; e < size; e++) {\r\n          if (board[r][c] === board[r - e][c + e]) {\r\n            count++;\r\n            tokens.push([r - e, c + e]);\r\n            if (count >= size) return [board[r][c], tokens];\r\n          } else {\r\n            count = 0;\r\n            tokens = [[r, c]];\r\n          }\r\n        }\r\n\r\n        // if (\r\n        //   board[r][c] === board[r - 1][c + 1] &&\r\n        //   board[r][c] === board[r - 2][c + 2] &&\r\n        //   board[r][c] === board[r - 3][c + 3]\r\n        // ) {\r\n        //   return board[r][c];\r\n        // }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function checkDiagonalLeft(board, size = 4) {\r\n  let [width, heigth] = [board[0].length, board.length];\r\n  // Check only if row is 3 or greater AND column is 3 or greater\r\n  for (let r = size - 1; r < heigth; r++) {\r\n    for (let c = size - 1; c < width; c++) {\r\n      if (board[r][c]) {\r\n        let count = 1;\r\n        let tokens = [[r, c]];\r\n        for (let e = 1; e < size; e++) {\r\n          if (board[r][c] === board[r - e][c - e]) {\r\n            count++;\r\n            tokens.push([r - e, c - e]);\r\n            if (count >= size) return [board[r][c], tokens];\r\n          } else {\r\n            count = 0;\r\n            tokens = [[r, c]];\r\n          }\r\n        }\r\n\r\n        // if (\r\n        //   board[r][c] === board[r - 1][c - 1] &&\r\n        //   board[r][c] === board[r - 2][c - 2] &&\r\n        //   board[r][c] === board[r - 3][c - 3]\r\n        // ) {\r\n        //   return board[r][c];\r\n        // }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function checkDraw(board) {\r\n  let [width, heigth] = [board[0].length, board.length];\r\n  for (let r = 0; r < heigth; r++) {\r\n    for (let c = 0; c < width; c++) {\r\n      if (board[r][c] === null) {\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n  return \"draw\";\r\n}\r\n\r\nexport function checkAll(board, size = 4) {\r\n  return (\r\n    checkVertical(board, size) ||\r\n    checkDiagonalRight(board, size) ||\r\n    checkDiagonalLeft(board, size) ||\r\n    checkHorizontal(board, size) ||\r\n    checkDraw(board)\r\n  );\r\n}\r\n\r\nexport function evaluationCheck(board, size = 4) {\r\n  let checkedDL = checkDiagonalLeft(board, size);\r\n  let checkedDR = checkDiagonalRight(board, size);\r\n  let checkedH = checkHorizontal(board, size);\r\n\r\n  return (\r\n    (checkedDL && checkedDL[0]) ||\r\n    (checkedDR && checkedDR[0]) ||\r\n    (checkedH && checkedH[0])\r\n  );\r\n}\r\n\r\nexport function playable(c, board) {\r\n  for (let r = board.length - 1; r >= 0; r--) {\r\n    if (!board[r][c]) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function clone(obj) {\r\n  return JSON.parse(JSON.stringify(obj));\r\n}\r\n\r\nexport function empty(board) {\r\n  let [width, heigth] = [board[0].length, board.length];\r\n  for (let r = 0; r < heigth; r++) {\r\n    for (let c = 0; c < width; c++) {\r\n      if (board[r][c]) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function evaluate(position) {\r\n  //returns position of lowest empty slot in column x\r\n  const maxY = (c, board) => {\r\n    let heigth = board.length - 1;\r\n    while (heigth >= 0 && board[heigth][c]) {\r\n      heigth--;\r\n    }\r\n    return heigth;\r\n  };\r\n\r\n  let { board, currentPlayer } = position;\r\n  let [width, heigth] = [board[0].length, board.length];\r\n\r\n  //finds next valid move in all columns\r\n  let maxYArray = [];\r\n  for (let c = 0; c < width; c++) {\r\n    maxYArray[c] = maxY(c, board);\r\n  }\r\n\r\n  //finds the heighest piece in each column touching another piece\r\n  let maxYHArray = [];\r\n  for (let c = 0; c < width; c++) {\r\n    maxYHArray[c] =\r\n      c !== 0 && maxYArray[c - 1] < maxYArray[c]\r\n        ? maxYArray[c - 1]\r\n        : maxYArray[c];\r\n    maxYHArray[c] =\r\n      c !== width - 1 && maxYArray[c + 1] < maxYArray[c]\r\n        ? maxYArray[c + 1]\r\n        : maxYHArray[c];\r\n    maxYHArray[c] = Math.min(0, maxYHArray[c] - 1);\r\n  }\r\n\r\n  console.log(maxYArray);\r\n  console.log(maxYHArray);\r\n\r\n  let winningMoves = 0;\r\n  for (let c = 0; c < heigth; c++) {\r\n    for (let r = maxYHArray[c]; r <= maxYArray[c]; r++) {\r\n      if (!board[r][c]) {\r\n        console.log(\"Checking\");\r\n\r\n        let opponent = -currentPlayer;\r\n\r\n        board[r][c] = currentPlayer;\r\n        if (checkAll(board) === currentPlayer) {\r\n          winningMoves++;\r\n        }\r\n\r\n        board[r][c] = opponent;\r\n        if (checkAll(board) === opponent) {\r\n          winningMoves--;\r\n        }\r\n\r\n        board[r][c] = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  console.log(winningMoves);\r\n\r\n  return winningMoves;\r\n}\r\n","import { checkAll, clone } from \"../utils/Utils\";\r\n\r\nexport default class Position {\r\n  constructor(board = [], currentPlayer = 1) {\r\n    this.board = board;\r\n    this.currentPlayer = currentPlayer;\r\n  }\r\n\r\n  isWinningMove = c => {\r\n    let board = clone(this.board);\r\n    let heigth = board.length;\r\n    let { currentPlayer } = this;\r\n\r\n    for (let r = heigth - 1; r >= 0; r--) {\r\n      if (!board[r][c]) {\r\n        board[r][c] = currentPlayer;\r\n        let checked = checkAll(board);\r\n        return checked && currentPlayer === checked[0];\r\n      }\r\n    }\r\n  };\r\n\r\n  play = (c, board = this.board) => {\r\n    let { currentPlayer } = this;\r\n    let heigth = board.length;\r\n\r\n    for (let r = heigth - 1; r >= 0; r--) {\r\n      if (!board[r][c]) {\r\n        board[r][c] = currentPlayer;\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.togglePlayer();\r\n\r\n    return board;\r\n  };\r\n\r\n  togglePlayer = () => {\r\n    this.currentPlayer = -this.currentPlayer;\r\n  };\r\n}\r\n","import { EVAL_WEIGHTS, MAX_VALUE, MIN_VALUE } from \"../consts/Consts\";\r\nimport { checkDraw, clone, evaluationCheck, playable } from \"../utils/Utils\";\r\nimport Position from \"./Position\";\r\n\r\nexport default class Solver {\r\n  constructor(width) {\r\n    let columns = [...Array(width).keys()];\r\n    columns.sort(\r\n      (a, b) =>\r\n        Math.abs(columns.indexOf(a) - columns.length / 2) -\r\n        Math.abs(columns.indexOf(b) - columns.length / 2)\r\n    );\r\n\r\n    this.columns = columns;\r\n  }\r\n\r\n  negamax = position => {\r\n    let { columns } = this;\r\n    let { board, currentPlayer } = clone(position);\r\n\r\n    // check for draw game\r\n    if (checkDraw(board)) {\r\n      return { value: 0 };\r\n    }\r\n\r\n    console.log(\"Board\", board, \"Player\", currentPlayer);\r\n    // check if current player can win next move\r\n    for (let c of columns) {\r\n      if (playable(c, board)) {\r\n        if (position.isWinningMove(c)) {\r\n          console.log(\"Winning \" + c);\r\n          return { move: c, value: MAX_VALUE };\r\n        }\r\n      }\r\n    }\r\n\r\n    let bestScore = { move: null, value: MIN_VALUE };\r\n\r\n    for (let c of columns) {\r\n      if (playable(c, board)) {\r\n        let p2 = new Position(board, currentPlayer);\r\n        p2.play(c); // It's opponent turn in P2 position after current player plays x column.\r\n\r\n        let score = -this.negamax(p2); // If current player plays col x, his score will be the opposite of opponent's score after playing col x\r\n        console.log(\r\n          \"Board\",\r\n          p2.board,\r\n          \"Player\",\r\n          p2.currentPlayer,\r\n          \"Score\",\r\n          score.value\r\n        );\r\n\r\n        if (score.value > bestScore.value) bestScore = score; // keep track of best possible score so far.\r\n      }\r\n    }\r\n\r\n    return bestScore;\r\n  };\r\n\r\n  negamaxAB = (position, alpha, beta, depth) => {\r\n    let { columns } = this;\r\n    let { board, currentPlayer } = position;\r\n\r\n    //console.log(\"Board \", board, \"Player\", currentPlayer, \"Depth: \", depth);\r\n\r\n    //check for draw game\r\n    if (checkDraw(board)) {\r\n      return { value: 0 };\r\n    }\r\n\r\n    // check if current player can win next move\r\n    for (let c of columns) {\r\n      if (playable(c, board)) {\r\n        if (position.isWinningMove(c)) {\r\n          //console.log(\"Winning \" + c, \"Board\", board);\r\n          return { move: c, value: MAX_VALUE };\r\n        }\r\n      }\r\n    }\r\n\r\n    //check if opponent can win next move\r\n    let p2 = new Position(clone(board), -currentPlayer);\r\n    for (let c of columns) {\r\n      if (playable(c, board)) {\r\n        if (p2.isWinningMove(c)) {\r\n          //console.log(\"Loosing \" + c, \"Board\", board);\r\n          return { move: c, value: MAX_VALUE };\r\n        }\r\n      }\r\n    }\r\n\r\n    if (depth === 0) {\r\n      let value = currentPlayer * this.evaluate(clone(position));\r\n      //console.log(\"Evaluated: \" + value, \"Board\", position.board);\r\n      return { value };\r\n    }\r\n\r\n    let bestScore = { move: null, value: MIN_VALUE };\r\n\r\n    // compute the score of all possible next move and keep the best one\r\n    for (let c of columns) {\r\n      if (playable(c, board)) {\r\n        let p2 = new Position(clone(board), currentPlayer);\r\n\r\n        p2.play(c); // It's opponent turn in P2 position after current player plays c column.\r\n\r\n        let result = this.negamaxAB(\r\n          p2,\r\n          { move: beta.move, value: -beta.value },\r\n          { move: alpha.move, value: -alpha.value },\r\n          depth - 1\r\n        );\r\n        result.value = -result.value;\r\n        if (!result.move) result.move = c;\r\n\r\n        // explore opponent's score within [-beta;-alpha] windows:\r\n        // no need to have good precision for score better than beta (opponent's score worse than -beta)\r\n        // no need to check for score worse than alpha (opponent's score worse better than -alpha)\r\n\r\n        if (result.value > bestScore.value) {\r\n          bestScore = clone(result); // prune the exploration if we find a possible move better than what we were looking for.\r\n        }\r\n\r\n        if (bestScore.value > alpha.value) {\r\n          alpha = clone(bestScore); // reduce the [alpha;beta] window for next exploration, as we only need to search for a position that is better than the best so far.\r\n        }\r\n\r\n        if (alpha.value >= beta.value) {\r\n          return clone(alpha);\r\n          //break;\r\n        }\r\n      }\r\n    }\r\n    return bestScore;\r\n  };\r\n\r\n  minimax = (position, alpha, beta, depth) => {\r\n    let { columns } = this;\r\n    let { board, currentPlayer } = position;\r\n\r\n    console.log(\"Board \", board, \"Player\", currentPlayer, \"Depth \", depth);\r\n\r\n    // check if current player can win next move\r\n    for (let c of columns) {\r\n      if (playable(c, board)) {\r\n        if (position.isWinningMove(c)) {\r\n          console.log(\"Winning \" + c);\r\n          return MAX_VALUE;\r\n        }\r\n      }\r\n    }\r\n\r\n    //check if opponent can win next move\r\n    let p2 = new Position(board, -currentPlayer);\r\n    for (let c of columns) {\r\n      if (playable(c, board)) {\r\n        if (p2.isWinningMove(c)) {\r\n          console.log(\"Loosing \" + c);\r\n          return MAX_VALUE;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (depth === 0) {\r\n      let value = this.evaluate(position);\r\n      console.log(\"Evaluated: \" + value);\r\n      return value;\r\n    }\r\n\r\n    // Computer\r\n    if (currentPlayer === -1) {\r\n      let bestScore = MIN_VALUE;\r\n\r\n      for (let c of columns) {\r\n        if (playable(c, board)) {\r\n          let p2 = new Position(board, currentPlayer);\r\n          p2.play(c); // It's opponent turn in P2 position after current player plays c column.\r\n\r\n          let result = this.minimax(p2, alpha, beta, depth - 1);\r\n          //result.move = c;\r\n\r\n          if (result > bestScore) {\r\n            bestScore = clone(result);\r\n          }\r\n          if (bestScore > alpha) {\r\n            alpha = clone(bestScore);\r\n          }\r\n          if (alpha >= beta) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      return bestScore;\r\n    }\r\n    // Human\r\n    else {\r\n      let bestScore = MAX_VALUE;\r\n\r\n      for (let c of columns) {\r\n        if (playable(c, board)) {\r\n          let p2 = new Position(board, currentPlayer);\r\n          p2.play(c); // It's opponent turn in P2 position after current player plays c column.\r\n\r\n          let result = this.minimax(p2, alpha, beta, depth - 1);\r\n          //result.move = c;\r\n\r\n          if (result < bestScore) {\r\n            bestScore = clone(result);\r\n          }\r\n          if (bestScore < alpha) {\r\n            alpha = clone(bestScore);\r\n          }\r\n          if (alpha >= beta) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      return bestScore;\r\n    }\r\n  };\r\n\r\n  evaluate = position => {\r\n    let { board, currentPlayer } = position;\r\n    let [width, heigth] = [board[0].length, board.length];\r\n    let myFours = 0;\r\n    let myThrees = 0;\r\n    let myTwos = 0;\r\n    let oppFours = 0;\r\n    let oppThrees = 0;\r\n    let oppTwos = 0;\r\n    for (let r = 0; r < heigth; r++) {\r\n      for (let c = 0; c < width; c++) {\r\n        if (!board[r][c]) {\r\n          let boardCopy = clone(board);\r\n\r\n          boardCopy[r][c] = currentPlayer;\r\n          if (currentPlayer === evaluationCheck(boardCopy, 4)) myFours++;\r\n          if (currentPlayer === evaluationCheck(boardCopy, 3)) myThrees++;\r\n          if (currentPlayer === evaluationCheck(boardCopy, 2)) myTwos++;\r\n\r\n          let opponent = -currentPlayer;\r\n          boardCopy[r][c] = opponent;\r\n          if (opponent === evaluationCheck(boardCopy, 4)) oppFours++;\r\n          if (opponent === evaluationCheck(boardCopy, 3)) oppThrees++;\r\n          if (opponent === evaluationCheck(boardCopy, 2)) oppTwos++;\r\n        }\r\n      }\r\n    }\r\n\r\n    let value =\r\n      (myFours - oppFours) * EVAL_WEIGHTS.FOURS +\r\n      (myThrees - oppThrees) * EVAL_WEIGHTS.THREES +\r\n      (myTwos - oppTwos) * EVAL_WEIGHTS.TWOS;\r\n\r\n    return value;\r\n  };\r\n\r\n  runMinimax = (board, currentPlayer, depth) => {\r\n    //let position = new Position(board, currentPlayer);\r\n    let { columns } = this;\r\n\r\n    let bestScore = MIN_VALUE;\r\n    let bestMove = null;\r\n    let alpha = { value: MIN_VALUE };\r\n    let beta = { value: MAX_VALUE };\r\n\r\n    for (let c of columns) {\r\n      if (playable(c, board)) {\r\n        let p2 = new Position(board, currentPlayer);\r\n        p2.play(c);\r\n\r\n        let result = this.minimax(p2, alpha, beta, depth);\r\n\r\n        if (bestScore < result) {\r\n          bestScore = clone(result);\r\n          bestMove = c;\r\n        }\r\n      }\r\n    }\r\n\r\n    return { move: bestMove, value: bestScore };\r\n  };\r\n\r\n  solve = (board, currentPlayer, depth, type = 1) => {\r\n    let position = new Position(board, currentPlayer);\r\n    if (type === 1) {\r\n      return this.negamaxAB(\r\n        position,\r\n        { value: MIN_VALUE },\r\n        { value: MAX_VALUE },\r\n        depth\r\n      );\r\n    } else if (type === 2) {\r\n      return this.negamax(position);\r\n    } else {\r\n      return this.runMinimax(board, currentPlayer, depth);\r\n    }\r\n  };\r\n}\r\n","import React, { Component } from \"react\";\nimport ClipLoader from \"react-spinners/ClipLoader\";\nimport {\n  ToastsContainer,\n  ToastsContainerPosition,\n  ToastsStore\n} from \"react-toasts\";\nimport \"./App.css\";\nimport Solver from \"./classes/Solver\";\nimport { EASY, HARD, MEDIUM } from \"./consts/Consts\";\nimport { checkAll, clone, playable } from \"./utils/Utils\";\n\nexport default class App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      width: 6,\n      heigth: 6,\n      player1: 1,\n      player2: -1,\n      currentPlayer: null,\n      board: [],\n      connected: [],\n      gameOver: false,\n      message: \"\",\n      depth: 2\n    };\n\n    this.play = this.play.bind(this);\n  }\n\n  componentDidMount() {\n    this.initBoard();\n  }\n\n  handleDepthChange = e => {\n    this.setState({ depth: e.target.value });\n  };\n\n  initBoard = () => {\n    let { width, heigth, player1, player2 } = this.state;\n    let board = [];\n    for (let r = 0; r < heigth; r++) {\n      board.push(new Array(width).fill(null));\n    }\n\n    let players = [player1, player2];\n    let initialPlayer = players[Math.round(Math.random())];\n\n    this.setState({\n      board,\n      connected: [],\n      currentPlayer: initialPlayer,\n      gameOver: false,\n      message: \"\"\n    });\n\n    if (initialPlayer === player2) {\n      setTimeout(() => {\n        let [board, newPlayer] = this.play(\n          Math.floor(width / 2) - Math.round(Math.random()),\n          initialPlayer\n        );\n        this.setState({ board, currentPlayer: newPlayer });\n      }, 500);\n    }\n  };\n\n  togglePlayer = () => {\n    return this.state.currentPlayer === this.state.player1\n      ? this.state.player2\n      : this.state.player1;\n  };\n\n  computeScores = (board, currentPlayer) => {\n    if (currentPlayer === this.state.player2) {\n      let { depth, width } = this.state;\n\n      let solver = new Solver(width);\n\n      let bestMove = solver.solve(clone(board), currentPlayer, depth);\n      return bestMove;\n    } else {\n      // Some exception handling, or maybe allow all\n    }\n  };\n\n  playHuman = async c => {\n    let { gameOver, currentPlayer, player2 } = this.state;\n    if (gameOver) {\n      ToastsStore.warning(\"Game over! Please start a new game.\");\n      //this.setState({ message: \"Game over. Please start a new game.\" });\n      return;\n    }\n    if (currentPlayer === player2) {\n      ToastsStore.warning(\"I'm thinking. Be patient!\");\n      return;\n    }\n\n    let [board, newPlayer] = this.play(c);\n    if (!board && !newPlayer) return;\n    await this.setState({ board, currentPlayer: newPlayer });\n    setTimeout(() => {\n      this.playAI(board, newPlayer);\n    }, 500);\n  };\n\n  playAI = (\n    board = this.state.board,\n    currentPlayer = this.state.currentPlayer\n  ) => {\n    let { gameOver, player1 } = this.state;\n    if (gameOver || currentPlayer === player1) {\n      return;\n    }\n    let bestMove = this.computeScores(clone(board), currentPlayer);\n    this.play(bestMove.move);\n  };\n\n  play = (c, currentPlayer = this.state.currentPlayer) => {\n    let { board, heigth, player1, player2 } = this.state;\n    let newPlayer = -currentPlayer;\n\n    if (playable(c, board)) {\n      // Place piece on board\n      for (let r = heigth - 1; r >= 0; r--) {\n        if (!board[r][c]) {\n          board[r][c] = currentPlayer;\n          break;\n        }\n      }\n\n      // Check status of board\n      let result = checkAll(board);\n      if (result && result[0] === player1) {\n        this.setState({\n          board,\n          connected: result[1],\n          gameOver: true,\n          currentPlayer: null\n        });\n        ToastsStore.success(\"You won!\");\n      } else if (result && result[0] === player2) {\n        this.setState({\n          board,\n          connected: result[1],\n          gameOver: true,\n          currentPlayer: null\n        });\n        ToastsStore.error(\"You lost!\");\n      } else if (result === \"draw\") {\n        this.setState({ board, gameOver: true, currentPlayer: null });\n        ToastsStore.warning(\"Draw game.\");\n      } else {\n        this.setState({ board, currentPlayer: newPlayer });\n        return [board, newPlayer];\n      }\n    } else {\n      // Inform somehow the user that the column is full\n      ToastsStore.warning(\"That column is full my friend.\");\n      return [null, null];\n    }\n\n    return [null, null];\n  };\n\n  render = () => {\n    let {\n      board,\n      message,\n      gameOver,\n      depth,\n      currentPlayer,\n      player1,\n      player2,\n      connected\n    } = this.state;\n    return (\n      <div>\n        <p className=\"message\">\n          Game complexity:{\" \"}\n          <input\n            value={EASY}\n            onChange={this.handleDepthChange}\n            checked={depth < MEDIUM}\n            name=\"depth\"\n            type=\"radio\"\n          ></input>\n          <label> Easy </label>\n          <input\n            value={MEDIUM}\n            onChange={this.handleDepthChange}\n            //checked={depth === MEDIUM}\n            name=\"depth\"\n            type=\"radio\"\n          ></input>\n          <label> Medium </label>\n          <input\n            value={HARD}\n            onChange={this.handleDepthChange}\n            //checked={depth === HARD}\n            name=\"depth\"\n            type=\"radio\"\n          ></input>\n          <label> Hard </label>\n        </p>\n        <p className=\"note\">\n          <b>*Note:</b> Greater complexity requires more time to calculate AI's\n          best move.\n        </p>\n        <p className=\"note\">First player will be randomly selected. You are the red player.</p>\n        <div\n          className=\"button\"\n          onClick={() => {\n            this.initBoard();\n          }}\n        >\n          New Game\n        </div>\n\n        <div className=\"tableContainer\">\n          <ClipLoader\n            css={\"position: absolute;\"}\n            sizeUnit={\"px\"}\n            size={150}\n            color={\"#123abc\"}\n            loading={currentPlayer === player2}\n          />\n          <table\n            className={currentPlayer === player2 ? \"tableLoading\" : \"table\"}\n          >\n            <thead></thead>\n            <tbody>\n              {board.map((row, i) => (\n                <Row\n                  key={i}\n                  rowIndex={i}\n                  row={row}\n                  play={this.playHuman}\n                  tokens={connected}\n                  gameOver={gameOver}\n                />\n              ))}\n            </tbody>\n          </table>\n        </div>\n\n        <p className=\"message\">\n          {gameOver\n            ? \"\"\n            : currentPlayer === player1\n            ? \"You play now\"\n            : \"I'm thinking...\"}\n        </p>\n        <p className=\"message\">{message}</p>\n\n        <ToastsContainer\n          store={ToastsStore}\n          position={ToastsContainerPosition.TOP_CENTER}\n        />\n      </div>\n    );\n  };\n}\n\nconst Row = ({ rowIndex, row, play, tokens, gameOver }) => {\n  return (\n    <tr>\n      {row.map((cell, i) => (\n        <Cell\n          key={i}\n          value={cell}\n          columnIndex={i}\n          play={play}\n          connected={tokens.some(a =>\n            [rowIndex, i].every((v, i) => v === a[i])\n          )}\n          gameOver={gameOver}\n        />\n      ))}\n    </tr>\n  );\n};\n\nconst Cell = ({ value, columnIndex, play, connected, gameOver }) => {\n  let color = \"white\";\n  if (value === 1) {\n    color = \"red\";\n  } else if (value === -1) {\n    color = \"yellow\";\n  }\n\n  return (\n    <td>\n      <div\n        className={`cell ${\n          gameOver ? (connected ? \"connected\" : \"notConnected\") : \"\"\n        }`}\n        onClick={() => {\n          play(columnIndex);\n        }}\n      >\n        <div className={color}></div>\n      </div>\n    </td>\n  );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}